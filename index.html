<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="app"></div>
  <script>
    const Fragment = Symbol('Fragment' );
    const Text = Symbol('Text' );
    const Comment = Symbol('Comment' );
    const Static = Symbol('Static' );
    const NULL_DYNAMIC_COMPONENT = Symbol();
    const isArray = Array.isArray;
    const isMap = (val) => toTypeString(val) === '[object Map]';
    const isSet = (val) => toTypeString(val) === '[object Set]';
    const isDate = (val) => val instanceof Date;
    const isFunction = (val) => typeof val === 'function';
    const isString = (val) => typeof val === 'string';
    const isSymbol = (val) => typeof val === 'symbol';
    const isObject = (val) => val !== null && typeof val === 'object';
    const normalizeKey = ({ key }) => key != null ? key : null;
    function normalizeClass(value) {
        let res = '';
        if (isString(value)) {
            res = value;
        }
        else if (isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                const normalized = normalizeClass(value[i]);
                if (normalized) {
                    res += normalized + ' ';
                }
            }
        }
        else if (isObject(value)) {
            for (const name in value) {
                if (value[name]) {
                    res += name + ' ';
                }
            }
        }
        return res.trim();
    }
    function normalizeProps(props) {
        if (!props)
            return null;
        let { class: klass, style } = props;
        if (klass && !isString(klass)) {
            props.class = normalizeClass(klass);
        }
        if (style) {
            props.style = normalizeStyle(style);
        }
        return props;
    }
    function normalizeStyle(value) {
      if (isArray(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
              const item = value[i];
              const normalized = isString(item)
                  ? parseStringStyle(item)
                  : normalizeStyle(item);
              if (normalized) {
                  for (const key in normalized) {
                      res[key] = normalized[key];
                  }
              }
          }
          return res;
      }
      else if (isString(value)) {
          return value;
      }
      else if (isObject(value)) {
          return value;
      }
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
          // single vnode without props
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          // props without children
          return createVNode(type, propsOrChildren);
        }
        else {
          // omit props
          return createVNode(type, null, propsOrChildren);
        }
      }
      else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    function createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) {
          warn$1(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
      }
      if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
          normalizeChildren(cloned, children);
        }
        return cloned;
      }
      // class component normalization.
      // if (isClassComponent(type)) {
      //   type = type.__vccOpts;
      // }
      // class & style normalization.
      if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject(style)) {
          // reactive state objects need to be cloned since they are likely to be
          // mutated
          if (isProxy(style) && !isArray(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      // encode the vnode type information into a bitmap
      const shapeFlag = isString(type)
        ? 1 /* ELEMENT */
        : isObject(type)
              ? 4 /* STATEFUL_COMPONENT */
              : isFunction(type)
                ? 2 /* FUNCTIONAL_COMPONENT */
                : 0;
      // if (shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {
      //   type = toRaw(type);
      //   warn$1(`Vue received a Component which was made a reactive object. This can ` +
      //     `lead to unnecessary performance overhead, and should be avoided by ` +
      //     `marking the component with \`markRaw\` or using \`shallowRef\` ` +
      //     `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
      // }
      return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
    }
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
          __v_isVNode: true,
          type,
          tag: type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          children,
          el: null,
          target: null
      };
      if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          // normalize suspense children
      }
      else if (children) {
          // compiled element vnode - if children is passed, only possible types are
          // string or Array.
          vnode.shapeFlag |= isString(children)
              ? 8 /* TEXT_CHILDREN */
              : 16 /* ARRAY_CHILDREN */;
      }
      // validate key
      if (vnode.key !== vnode.key) {
          warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      // track vnode for block tree
     
      return vnode;
    }
    function createTextVNode(text = ' ', flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function normalizeChildren(vnode, children) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
            children = null;
        }
        else if (isArray(children)) {
            type = 16 /* ARRAY_CHILDREN */;
        }
        else if (typeof children === 'object') {
            if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
                // Normalize slot to plain children for plain element and Teleport
                const slot = children.default;
                if (slot) {
                    // _c marker is added by withCtx() indicating this is a compiled slot
                    slot._c && (slot._d = false);
                    normalizeChildren(vnode, slot());
                    slot._c && (slot._d = true);
                }
                return;
            }
            else {
                type = 32 /* SLOTS_CHILDREN */;
                const slotFlag = children._;
                if (!slotFlag && !(InternalObjectKey in children)) {
                    children._ctx = currentRenderingInstance;
                }
                else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                    // a child component receives forwarded slots from the parent.
                    // its slot type is determined by its parent's slot type.
                    if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                        children._ = 1 /* STABLE */;
                    }
                    else {
                        children._ = 2 /* DYNAMIC */;
                        vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                    }
                }
            }
        }
        else if (isFunction(children)) {
            children = { default: children, _ctx: currentRenderingInstance };
            type = 32 /* SLOTS_CHILDREN */;
        }
        else {
            children = String(children);
            // force teleport children to array so it can be moved around
            if (shapeFlag & 64 /* TELEPORT */) {
                type = 16 /* ARRAY_CHILDREN */;
                children = [createTextVNode(children)];
            }
            else {
                type = 8 /* TEXT_CHILDREN */;
            }
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
    }
    function createVirtualDOM(tag, props, children) {
      return {
        tag,
        props,
        children
      };
    }

    // 示例用法
    const virtualDOM = createVirtualDOM('div', { id: 'container' }, [
      createVirtualDOM('h1', { class: 'title' }, ['Hello, Virtual DOM']),
      createVirtualDOM('p', { class: 'content' }, ['This is a simple example'])
    ]);
    function render(vnode, container) {
      // 创建真实DOM元素
      const el = document.createElement(vnode.tag);

      // 设置元素属性
      if (vnode.props) {
        for (const key in vnode.props) {
          el.setAttribute(key, vnode.props[key]);
        }
      }

      // 递归挂载子元素
      if (vnode.children) {
        vnode.children.forEach(child => {
          if (typeof child === 'object') {
            render(child, el);
          } else {
            el.appendChild(document.createTextNode(child));
          }
        });
      }

      // 将创建的元素挂载到指定容器中
      container.appendChild(el);
    }
    function parseTemplateToRenderFunction(template) {
      // 将HTML模板字符串转换为一个DOM元素
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = template.trim();

      // 假设模板仅有一个根节点
      const rootElement = tempDiv.firstChild;

      // 递归函数转换DOM节点为渲染函数代码
      function generateRenderFunctionCode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          // 文本节点：直接返回文本内容
          return `\`${node.textContent}\``;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          // 元素节点：转换成h函数调用
          const tag = node.tagName.toLowerCase();
          const children = Array.from(node.childNodes).map(generateRenderFunctionCode)
          return createVirtualDOM(tag, {}, children)
        }
      }

      // 生成渲染函数字符串
      const renderVirtualDOM = generateRenderFunctionCode(rootElement)

      // 返回可用于实际组件定义的渲染函数字符串
      return renderVirtualDOM
    }

    // 示例
    const template = `<div>Hello, <span>world!</span></div><div>Hello, <span>world!</span></div>`;
    console.log(parseTemplateToRenderFunction(template));
    const virtualDOMByTemplate = parseTemplateToRenderFunction(template);
    console.log(virtualDOMByTemplate, 'virtualDOMByTemplate')
    debugger
    console.log(createVNode(virtualDOMByTemplate), 'createVNode');
    render(virtualDOMByTemplate, document.getElementById('app'))
  </script>
</body>

</html>